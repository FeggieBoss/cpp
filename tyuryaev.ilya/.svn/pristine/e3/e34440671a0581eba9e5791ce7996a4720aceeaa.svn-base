#include <iostream>

#include "my_vector.h"

namespace product
{

    class Product
    {
    public:
        Product(const char *name, int quantity, double price) : quantity_(quantity), price_(price)
        {
            copy_name(name);
        }
        ~Product()
        {
            delete[] name_;
        }
        Product(const Product &prod)
        {
            copy_name(prod.name_);
            quantity_ = prod.quantity_;
            price_ = prod.price_;
        }
        friend std::ostream &operator<<(std::ostream &out, const Product &prod);

    private:
        void copy_name(const char *name)
        {
            name_ = new char[strlen(name) + 1];
            strcpy(name_, name);
        }

    private:
        char *name_; // Указатель владеет C-style строкой, на которую указывает.
        int quantity_;
        double price_;
    };

    std::ostream &operator<<(std::ostream &out, const Product &prod)
    {
        out << prod.name_ << " " << prod.quantity_ << " " << prod.price_;
        return out;
    }

    void print(const containers::my_vector<Product> &v)
    {
        std::cout << v << std::endl;
    }

} // namespace product

template <typename T>
void test_my_vector(T a, T b)
{
    containers::my_vector<T> v1;
    //std::cout << "test_my_vector" << '\n';
    v1.push_back(a);
    v1.push_back(b);
    v1.push_back(a);
    //std::cout << v1[0] << " " << v1[1] << '\n';
    std::cout << v1 << '\n';
    assert(v1.size() == 3);
    assert(v1.capacity() == 4);
    containers::my_vector<T> v2(v1);
    //std::cout << v2 << '\n';
    v2.pop_back();
    v2.pop_back();
    assert(v2.size() == 1);
    //std::cout << v2 << '\n';

    containers::my_vector<T> v3 = v2;
    //std::cout << v3 << '\n';
    v3.clear();
    assert(v3.empty());
    v2.pop_back();
    assert(v2.empty());
    //std::cout << "\n\n\n\n\n\n";
}

template <typename T>
void test_my_vector_default_constructible(T a, T b)
{
    containers::my_vector<T> v1(2);
    //std::cout << "test_my_vector_default_constructible" << '\n';
    v1.push_back(b);
    v1.push_back(b);
    v1.push_back(a);
    //std::cout << v1[0] << " " << v1[1] << '\n';
    //std::cout << v1 << '\n';
    assert(v1.size() == 5);
    assert(v1.capacity() == 8);
    containers::my_vector<T> v2(v1);
    //std::cout << v2 << '\n';
    v2.resize(10);
    v2.pop_back();
    v2.pop_back();
    assert(v2.size() == 8);
    //std::cout << v2 << '\n';

    containers::my_vector<T> v3 = v2;
    //std::cout << v3 << '\n';
    v3.clear();
    assert(v3.empty());

    containers::my_vector<T> v4(10);
    assert(v4.size() == 10);
    assert(v4.capacity() == 16);
    v4.resize(0);
    assert(v4.empty());
    assert(v4.capacity() == 16);

    containers::my_vector<T> v5;
    assert(v5.empty());
    assert(v5.capacity() == 1);

    v5.resize(5);
    //std::cout << v5.capacity() << '\n';

    assert(v5.size() == 5);
    assert(v5.capacity() == 8);

    v5.resize(15);
    //std::cout << v5.capacity() << '\n';

    assert(v5.size() == 15);
    assert(v5.capacity() == 16);

    v5.resize(10);
    //std::cout << v5.capacity() << '\n';

    assert(v5.size() == 10);
    assert(v5.capacity() == 16);

    v5.resize(17);
    //std::cout << v5.capacity() << '\n';

    assert(v5.size() == 17);
    assert(v5.capacity() == 32);

    v5.resize(0);
    //std::cout << v5.capacity() << '\n';

    assert(v5.size() == 0);
    assert(v5.capacity() == 32);
}

int main()
{
    test_my_vector<int>(5, 10);
    test_my_vector<product::Product>(product::Product("asdf", 4, 12.0), product::Product("qwe", -1, 7.5));
    test_my_vector_default_constructible<int>(1, 2);
    return 0;
}
