#include "my_vector.h"

template <typename T>
containers::my_vector<T>::my_vector() : capacity_(init_cp), size_(0)
{
    array_ = (T *)(new char[capacity_ * sizeof(T)]);
}

template <typename T>
containers::my_vector<T>::my_vector(std::size_t n)
{
    if (!std::is_default_constructible<T>::value)
        assert(false && "Elements in vector is not DefaultConstructible");

    size_ = capacity_ = n;
    array_ = new T[n]{};
}

template <typename T>
T &containers::my_vector<T>::operator[](std::size_t index) const
{
    return array_[index];
}

template <typename T>
void containers::my_vector<T>::move_array(char *to, char *from, std::size_t numb)
{
    for (std::size_t i = 0; i < numb; ++i)
        new ((T *)(to + i * sizeof(T))) T(*((T *)(from + i * sizeof(T))));
}

template <typename T>
void containers::my_vector<T>::assign(const my_vector<T> &other)
{
    capacity_ = other.capacity_;
    size_ = other.size_;
    array_ = (T *)(new char[capacity_ * sizeof(T)]);
    move_array((char *)array_, (char *)other.array_, size_);
}

template <typename T>
void containers::my_vector<T>::free_vec(my_vector<T> &vec, std::size_t from)
{
    for (std::size_t i = from; i < size_; ++i)
        vec[i].~T();
}

template <typename T>
containers::my_vector<T>::my_vector(const my_vector<T> &other)
{
    assign(other);
}

template <typename T>
containers::my_vector<T> &containers::my_vector<T>::operator=(const my_vector<T> &other)
{
    if (this == &other)
        return other;

    free_vec(*this);
    delete[](char *) array_;
    assign(other);
    return *this;
}

template <typename T>
containers::my_vector<T>::~my_vector()
{
    free_vec(*this);
    delete[](char *) array_;
    capacity_ = size_ = 0;
    array_ = nullptr;
}

template <typename T>
std::size_t containers::my_vector<T>::size() const
{
    return size_;
}

template <typename T>
std::size_t containers::my_vector<T>::capacity() const
{
    return capacity_;
}

template <typename T>
bool containers::my_vector<T>::empty() const
{
    return (size_ == (std::size_t)0);
}

template <typename T>
void containers::my_vector<T>::reserve(std::size_t n)
{
    if (n <= capacity_)
        return;
    capacity_ = n;

    char *mem = new char[capacity_ * sizeof(T)];
    move_array(mem, (char *)array_, size_);
    free_vec(*this);
    delete[](char *) array_;
    array_ = (T *)mem;
}

template <typename T>
void containers::my_vector<T>::resize(std::size_t n)
{
    if (!std::is_default_constructible<T>::value)
        assert(false && "Elements in vector is not DefaultConstructible");

    if (capacity_ < n)
    {
        reserve(std::max(n, cp_multiplier * capacity_));
        for (std::size_t i = size_; i < n; ++i)
            new ((T *)((char *)array_ + i * sizeof(T))) T();
    }
    if (size_ < n)
    {
        free_vec(*this, n);
        memset((char *)(array_ + size_), 0, (n - size_) * sizeof(T));
    }
    size_ = n;
}

template <typename T>
void containers::my_vector<T>::push_back(const T t)
{
    if (size_ == capacity_)
        reserve(cp_multiplier * capacity_);
    new (array_ + size_) T(t);
    ++size_;
}

template <typename T>
void containers::my_vector<T>::pop_back()
{
    array_[size_ - 1].~T();
    --size_;
}

template <typename T>
void containers::my_vector<T>::clear()
{
    free_vec(*this);
    size_ = 0;
}